---
layout: post
title: プログラムで暦を計算する場合のアルゴリズムについて
date: 2023/2/3
---

# はじめに

西暦を扱う為の計算ロジックについてのメモです。最近のプログラム言語(ライブラリ) は、十分な機能をもった日付クラスや日付を扱うAPIを備えていますので、本記事が役に立つ機会は少ないかもしれません。しかし、昔だと便利な日付計算の API が標準でなくって、わざわざ自前でプログラムを組んだものです(大昔です)。この手の情報は年々見つけ辛くなっている気がするので、参考までに残しておきます。

ここでは自前でプログラムを組む場合の、簡単な計算ロジックについて説明しています。尚、少し改定をいれていますが、この記事のオリジナルは大昔に(1998頃)書いたものです。

# グレゴリオ暦

暦のアルゴリズムで難しい点は、暦は、時代や文化、宗教によって非常に多種多様で、そしてあまり厳密でない(つまり曖昧な)点です。今日日本で良く使われている暦はグレゴリオ暦といいますが、このグレゴリオ暦も、過去からずっと使われ続けて来たわけではありません。

## グレゴリオ暦の採用された日

グレゴリオ暦が採用された日は、国や地域によって異なります。たとえば、ヨーロッパ大陸の主な国でグレゴリオ暦を採用したのは、1582年です。これらの国では、西暦 1582/10/04 の次は西暦 1582/10/15 になります。ところがイギリスやアメリカがグレゴリオ暦を採用したのは1752年。1752/09/02 の次が 1752/09/14 になります。日本では明治以降にグレゴリオ暦が採用されました。

## グレゴリオ暦以外の暦

グレゴリオ暦が採用される以前のヨーロッパでは、ユリウス暦が用いられていました。UNIXシステム上の"cal"というコマンドは、多くの場合、イギリス・アメリカの慣習にしたがって、カレンダーを出力しています。試しに1752 年9月のカレンダーを表示させてみてください。1752年以前についてのこのコマンドの出力はユリウス暦の日付です。

また、グレゴリオ暦以外の他の暦も、決して過去の遺物ではありません。今日においても、文化や宗教の違いにより、さまざまな種類の暦が存在し、日常的に使われています。よって、真に国際化(I18N)を目指すソフトは、本当は、これら全ての暦を考慮すべきなのかもしれません。

## グレゴリオ暦の正確さ

グレゴリオ暦は、世界中の暦の中でも、もっとも正確な暦の一つです。天文観測上の一年、つまり地球の公転周期は365.2422日ですが、グレゴリオ暦は、これを365.2425と近似しています。余談ですが中南米の古代マヤ文明の暦は、グレゴリオ暦よりさらに正確で、一年を365.2420日として当時の脅威的な天文観測技術が窺えます。
さて、話しを戻しますが、グレゴリオ暦の一年365.2425日は次の様な分数式の和で表す事ができます。

```
365.2425 = 365 + 1/4 - 1/100 + 1/400
```

この式から、平年の一年が365日で、4で割り切れる年でかつ100で割り切れない年、または、400で割り切れる年を平年より一日多い366日の閏年としています。試しに、実際の地球の公転周期の365.2422日を分数の和で書くと…

```
365.2422 = 365 + 1/4 - 1/100 + 1/400 - 1/4000 - 1/20000
```

現行のグレゴリオ暦は、かなり正確な暦ですが、4000年に一日は、ズレが生じてしまう事が分かります。さらにこの4000年に一度のズレを補正しても20000年に一日はズレがでます。現行のグレゴリオ暦にはこのズレを補正するルールはありません。

# 予備知識

さまざまな国や地域の文化、宗教に対応し、かつ、過去から未来にかけて長期に渡り通用する、汎用的な暦を考察するのは、テーマとしては面白いのですが、実際には、非常に難しい事が分かります。世界中のあらゆる暦を網羅するのは不可能ですし、それに、遠い将来まで通用する暦は現存しません。
できれば、永久に通用する暦が欲しいところですが、実際には未来の事は予測が付きません。遠い将来は、時代の要求から現在の暦(グレゴリオ暦)以外の新しい暦が採用されている可能性だってあります。少なくても 西暦 4000 年より未来には、今のグレゴリオ暦にも修正が必要です。
だいたい、4000年も先の未来だとちょっと SF っぽい話しになりますが時代はきっと宇宙時代、宇宙暦のようなまるっきり別の暦が必要かもしれませんしね。
そこで、本文書では、グレゴリオ暦とユリウス暦についてのみ扱う事にしましょう。大抵のシステムでは、グレゴリオ暦をサポートすれば十分です。

具体的な実装を示す前に、必要な予備知識として、幾つかの概念とアルゴリズムを紹介します。

## ユリウス積日

「ユリウス積日」(ユリウス暦とは違う)とは天文学の分野で使われているもので、ユリウス暦で紀元前4713 年1月1日を起点として現在に至るまでの「通し日数」の事です。暦を扱う場合、計算の都合上、通し日数があると便利ですのでこれを流用します。もちろん、勝手に起点を決めても良いですし、グレゴリオ暦の 1年 1月 1日 を基点にする方が簡単なのですが、それでは面白くないので、少しだけアレンジして、このユリウス積日を利用します。
ここで注意ですが、「ユリウス暦」と「ユリウス積日」は、名前は似ていますが違う物ですので区別してください。(歴史的には関連はある様ですが詳しくは私も存じません)。また、余談ですが天文学の分野で用いているユリウス積日は、本当は正午(12:00pm)を起点にするそうです。しかし、ここでは、それは不便なので、同じ日の0:00am を起点として扱う事にします。

## グレゴリオ暦とユリウス暦

ユリウス暦は、グレゴリオ暦が採用される前のヨーロッパで広く使われていた暦です。ユリウス暦の施行年は紀元前 46 年頃だそうですが、施行されても長い間は混乱が続いたようで、当時の人々の生活とは必ずしも一致していなかったようです。そう考えると、ユリウス暦を用いて正確に日付を計算しても、あまり意味がないのかもしれません。しかし、今回のプログラムにはユリウス暦も考慮する事にします。
さて、ユリウス暦の一年は365.25日です。

```
365.25 = 365 + 1/4
```

よって、平年が365日、4年に1年は閏年で366日になります。
昔のヨーロッパでは、宗教的な理由で、春分の日には重要な意味がありました。しかし、ユリウス暦を長年使っていると、本当の春分の日(太陽が真東からのぼる日)と、実際の暦との差が次第に大きくなってきます。そこで、とうとう1582年になって、このズレを修正するために、より誤差の少ないグレゴリオ暦が施行されることになります。グレゴリオ暦の一年は365.2425です。

```
365.2425 = 365 + 1/4 - 1/100 + 1/400
```

平年はユリウス暦と同じ365日ですが、閏年の条件が違います。グレゴリオ暦では、西暦が4で割り切れてかつ100で割り切れない年、または、400で割り切れる年を閏年としています。またご存知のとおり閏年には2/29日が追加されます。
 
次に、ユリウス暦からグレゴリオ暦に移行したのは何年にするかが問題ですが、移行日は、国や地域によって大きく異なります。そこで、今回は、世界で始めてグレゴリオ暦を採用した年を、移行日にします。すなわち、1582年。西暦1582/10/04の次は西暦1582/10/15です。一方、多くのUNIXのシステムでは、UNIXの生まれたアメリカの文化に合わせて、1752を移行日に設定しています。この違いがクリティカルになる場合は注意してください。

## ユリウス積日との相対関係

グレゴリオ暦は 1582/10/15 より昔は存在しません。ユリウス暦でも紀元前 46 年より昔は本当は存在しません。しかし、計算の都合上は、過去に遡って日付を考える必要があります。この場合の様に、過去に遡って今の暦のルールを適用した暦の事を「予期暦」と言います。
予期暦を用いると、ユリウス積日は、ユリウス暦の紀元前4713年1月1日が起点です。この計算でいくと、ユリウス暦の1/1/1は、ユリウス積日の1721423日になります。同じ様にグレゴリオ暦で、予期暦として1/1/1を考えると、この日は、ユリウス積日では1721425日にあたります。また、グレゴリオ暦施行日である1582/10/15は、ユリウス積日では2299161日です。表にすると次の様になります。


| 暦と日付                   | ユリウス積日   |
| --------------------------|-----------------|
| ユリウス暦 BC 4713/1/1     | 1              |
| ユリウス暦 AD 1/1/1        | 1721424        | 
| グレゴリオ暦 AD 1/1/1      | 1721426        |
| グレゴリオ暦 AD 1582/10/15 | 2299161        |


## Zellerの曜日計算の公式

曜日を計算する為には、実は、有名な公式があります。これは Zeller公式と呼ばれるもので、西暦(グレゴリオ暦) y/m/d の曜日は次の公式で求められます。ここで、月が1月2月の場合は、前年の13月14月と置き換えて計算します。また、この式の `[m]` はガウス演算子で、m 越えない最大の整数を意味します。グレゴリオ暦での曜日の計算では正の数値しか扱いませんので、結局小数点以下切捨てと同じ意味になります。

```
( y + [y/4] - [y/100] + [y/400] + [2.6m + 1.6] + d ) mod 7
```

この式の評価値が、0だったら日曜日、1だったら月曜日、以下同様に、6なら土曜日です。またC/C++の疑似コードで書くと次の様になります。

``` c++
long day_of_week(long y, long m, long d){
	if (m <= 2) { m += 12; y--; }
	return (y + y / 4 - y / 100 + y / 400 + (13 * m + 8) / 5 + d) % 7
}
```

参考までに、公式中のマジックナンバー、2.6は、2月を除く月の日数の平均の30.6を、曜日の数7で割った余りから導き出された値です。`30.6=7x4+2.6`。また1.6は補正値です。
また、C/C++の疑似コードでは、y,m,dは整数型として宣言していますので、個々の項の演算結果は自動的に小数点以下が切捨てられます。さらに、実数計算を避ける為に最適化が施されていて `2.6m+1.6` は `(13*m+8)/5` と置き換えられています。この様に置換すると、暗黙の型変換も起きず、全て整数型で計算されます。

尚、正確には、上記の式は、Zellerの与えた元の公式から若干修正されています。オリジナルの公式は、西暦を下2桁で扱う等、昔の大きい整数が扱えない計算機でも計算できるように、工夫されている様ですが、今日の計算機ではその必要はないと思います。

## 積日計算

Zellarの式は曜日の計算の為の公式ですが、ちょっと変形すると、積日の計算に使えます。すなわち、グレゴリオ暦1/1/1からのy/m/dの通し日数(積日)は、

```
(y-1)*365 + [y/4] - [y/100] + [y/400] + [30.6 * (m-1) - 1.7] + d
```

で計算できます。ここでもやはり、mが1月2月の場合は、前年の13月14月として計算します。さて、このアルゴリズムをC/C++の疑似コードで書くと次の様になります。

``` c++
long nday(long y, long m, long d){
    if (m <= 2) { m += 12; y--; }
    return (y-1)*365 + y/4 - y/100 + y/400 + (153*m-162)/5 + d;
}
```

これは、グレゴリオ暦での積日の計算式ですが、ユリウス暦での積日の計算はもっと簡単に導けるでしょう。また、これらの積日の計算式があれば、先のZellar の公式は不要ですね。曜日を求める為には積日を7で割った余りを用いればいいのですから。

## その他の考慮事項

本当のユリウス暦では、閏年は2/29が増えるのではなく、2/24を繰り返すらしいのですが、詳しい事は調査不足では分かりません。しかし、現代のシステム開発現場では、殆どの場合、昔の暦の事情には感心は無いと思われます。  実際、私の手もとの Linux システムで試しても、 2/29 が増やしています。そこでこの資料で説明するプログラムも単純に 2/29 を増やす事にします。
また、昔の一年の始まりは、春分の日を含む3月だったようです。しかし、3月が1月に移行した年も分からないし、こちらも特に感心は無いと思われますので、今回は全て1年の始まりは1/1と仮定します。
余談になりますが、閏年に追加される日って、実はその年の最後に一日を追加したんですね(３月が新年なので)。何故2/29なんて中途半端な日付なんだろうって、昔は思ってました。もう一つ余談になりますが、かの有名なノストラダムスの予言の「1999年第7の月」っていうのは、7月じゃなくて、今の暦に置き換えると1999年9月になると思われます。

# C++の実装

では、以上を踏まえて、C++のコードを提示します。といっても、完全なAPIセットではありません。以下のコードは、アルゴリズムを理解する為のサンプルと思ってください。実用に耐えるAPIセットにするなら、日付の和や差の計算など、この他にもAPIは沢山必要になると思います。また、以下のコードでは、エラー処理や、不正な日付をチェックするロジックも省いています。以下のサンプルでは、不正な日付を与えるとエラーにはならず、単にデタラメな積日が返ります(GIGO)。
これまでの文章を読んで頂ければ、解説は不要と思いますので、あとはハックしてみてください。

``` c++
// ユリウス暦  1/1/1 の前日のユリウス積日
const   long   FIRST_DAY_OF_JULI = 1721423l;
// グレゴリオ暦 1/1/1 の前日のユリウス積日
const   long   FIRST_DAY_OF_GREG = 1721425l;
// グレゴリオ暦施行日 (1582/10/15) のユリウス積日
const   long   IGREG = 2299161l;
// グレゴリオ暦施行年
const   long   IGREGYEAR = 1582l;
 
//
// 閏年かどうかの判定
//
bool is_leap_year(int y)
{
	if   (IGREGYEAR <= y){
		return   (y % 4 == 0 && (y % 100 != 0 || y % 400 == 0));
	}
	else   {
		return   (y % 4 == 0);
	}
}

//
// 日付をユリウス積日に変換する。
// 内部で、
//     gdate_to_nday()
//     jdate_to_nday()
// を呼んでいるだけです。
//
long date_to_nday(int y, int m, int d)
{
	// グレゴリオ暦とみなして計算する。
	long   nday = gdate_to_nday(y, m, d);
	// 結果がグレゴリオ暦施行日より前ならユリウス暦として再計算
	if   (IGREG > m_nday){
		nday = jdate_to_nday(y, m, d);
	}
	return   nday;
}

//
// グレゴリオ暦日付をユリウス積日に変換する
// 負の年はサポートせず。
//
long gdate_to_nday(int y, int m, int d)
{
	if   (m <= 2) { m += 12; y--; }
	return   (y - 1) * 365 + y / 4 - y / 100 + y / 400 + (153 * m - 162) / 5 + d + FIRST_DAY_OF_GREG;
}

//
// ユリウス暦日付をユリウス積日に変換する
// 負の年は紀元前とする。
//
long jdate_to_nday(int y, int m, int d)
{
	if   (y < 0) { y++; }   // 負の年代のサポート
	if   (m <= 2) { m += 12; y--; }
	return   (y - 1) * 365 + y / 4 + (153 * m - 162) / 5 + d + FIRST_DAY_OF_JULI;
}

//
// ユリウス積日を日付に変換します。
// 内部で
//     nday_to_gdate()
//     nday_to_jdate()
// を呼んでいるだけです。
//
void nday_to_date(long n, int& y,  int& m,  int& d)
{
	// グレゴリオ暦施行日以降ならグレゴリオ暦で計算
	if   (IGREG < = n){
		nday_to_gdate(n, y, m, d);
	}
	// ユリウス暦として計算
	else   {
		nday_to_jdate(n, y, m, d);
	}
}


//
// ユリウス積日をグレゴリオ暦の日付に直す
// 負の年代はサポートせず
//
void nday_to_gdate(long n, int& y, int& m, int& d)
{
	long   left;
	// ユリウス積日をグレゴリオ暦の積算日に直す
	n -= FIRST_DAY_OF_GREG;
	// 年の計算
	y = (n / 365) + 1;
	while   ((left = n - ((y - 1) * 365 + y / 4 - y / 100 + y / 400 + 60)) < 0) y--;
	left += 60;                     // 60 は 3/1 までの年日
	// 月日の計算 [m = (left + 30.6 + 1.7)/30.6;]
	m =   int   ((10 * left + 323) / 306);
	d =   int   (left - (153 * m - 162) / 5);
	// 調整 (1,2 月は前年 13,14 月としていた為 )
	if   (m > 12){ y++; m -= 12; }
}

//
// ユリウス積日をユリウス暦の日付に直す
// 負の年代は紀元前を表す。
//
void nday_to_jdate(long n, int& y, int& m, int& d)
{
	long   left;
	// ユリウス積日をユリウス暦の積算日に直す
	n -= FIRST_DAY_OF_JULI;
	if   (n > 0){                         // A.D.
		// 元の式は [y = (n-60.0+0.5)/365.25 + 1.0;]
		y = (4 * n + 1223) / 1461;
		left = n - ((y - 1) * 365 + y / 4);
	}
	else   {                       // B.C
		// 元の式は [y = (n-60.0)/365.25 - 1.0;]
		y = (4 * n - 1701) / 1461;
		left = n - ((y)* 365 + (y + 1) / 4);
	}
	// 月日の計算
	m =   int   ((10 * left + 323) / 306);
	d =   int   (left - (153 * m - 162) / 5);
	// 調整 (1,2 月は前年 13,14 月としていた為 )
	if   (m > 12){ y++; m -= 12; }
}

//
// 曜日を計算する
//
long day_of_week(int y, int m, int d)
{
	return date_to_nday(y, m, d) % 7;
}
```

# 参考図書

* C言語によるアルゴリズム辞典。奥村晴彦著。技術評論社。ISBN4-87408-414-1
* 暦の科学。山崎昭、久保良雄著。講談社。ISBN4-06-118183-1
* 現代こよみ読み書き事典。岡田芳朗、阿久根末忠編著。柏書房。ISBN4-7601-0951-X


